<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Team 14</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Kaushan+Script' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700' rel='stylesheet' type='text/css'>

    <!-- Custom styles for this template -->
    <link href="css/agency.min.css" rel="stylesheet">

  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="#page-top">Team 14</a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          Menu
          <i class="fa fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav text-uppercase ml-auto">

            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#team">Team</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#labs">Labs</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#milestones">Milestones</a>
            </li>
			<li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#documents">Documents</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href=https://github.com/kristinanemeth/group14>Github</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <!-- Header -->
    <header class="masthead">
      <div class="container">
        <div class="intro-text">
          <div class="intro-heading text-uppercase">The Little Arduino That Could</div>
          <a class="btn btn-primary btn-xl text-uppercase js-scroll-trigger" href="https://github.com/kristinanemeth/group14/raw/master/docs/Ethics%20Assignment%20Final.pdf">Read Our Ethics Paper!</a>
        </div>
      </div>
    </header>
	
	<!-- Team -->
    <section class="bg-light" id="team">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center">
            <h2 class="section-heading text-uppercase">Team Members</h2>
            <h3 class="section-subheading text-muted">if y'all want better pictures, upload them to "img/team" and make sure it's roughly square; else you'll have a nice, distorted face</h3>
          </div>
        </div>
        <div class="row">
          <div class="col-sm-4">
            <div class="team-member">
              <img class="mx-auto rounded-circle" src="img/team/gvd.jpg" alt="">
              <h4>Giacomo di Liberto</h4>
              <p class="text-muted">gvd8</p>
              <p class="text-muted">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
            </div>
          </div>
          <div class="col-sm-4">
            <div class="team-member">
              <img class="mx-auto rounded-circle" src="img/team/mdf.jpg" alt="">
              <h4>Michelle Feng</h4>
              <p class="text-muted">mf568</p>
              <p class="text-muted">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
            </div>
          </div>
          <div class="col-sm-4">
            <div class="team-member">
              <img class="mx-auto rounded-circle" src="img/team/kan.jpg" alt="">
              <h4>Kristina Nemeth</h4>
              <p class="text-muted">kan57</p>
              <p class="text-muted">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
            </div>
          </div>
		  
		  <div class="col-sm-4">
            <div class="team-member">
              <img class="mx-auto rounded-circle" src="img/team/rms.jpg" alt="">
              <h4>Russell Silva</h4>
              <p class="text-muted">rms438</p>
              <p class="text-muted">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
            </div>
          </div>
		  
		  <div class="col-sm-4">
            <div class="team-member">
              <img class="mx-auto rounded-circle" src="img/team/ys.jpg" alt="">
              <h4>Joan Song</h4>
              <p class="text-muted">ys449</p>
			  <p class="text-muted">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
              
            </div>
          </div>
        </div>
        <div class="row">
          <div class="col-lg-8 mx-auto text-center">
            <p class="large text-muted">Sometimes we like each other</p>
          </div>
        </div>
      </div>
    </section>
	
<hr class="symbol">

    <!-- Portfolio Grid -->
    <section class="bg-light" id="labs" background-color ="red">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center">
            <h2 class="section-heading text-uppercase">Labs</h2>
            <h3 class="section-subheading text-muted">Send help i can't create thumbnails</h3>
          </div>
        </div>
        <div class="row">
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal1">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/01-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			  <br>
              <p class="text-muted" align = "center">introduction to Arduino</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal2">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/02-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			  <br>
              <p class="text-muted" align = "center">in which we learn about microphones and IR sensors</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal3">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/03-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
              <br>
              <p class="text-muted" align = "center">we play songs and display squares</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal4">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/04-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
              <br>
              <p class="text-muted" align = "center">how to create radio communications</p>
            </div>
          </div>
		</div>
		</div>
    </section>
<hr class="symbol">

    <!-- Portfolio Grid -->
    <section class="bg-light" id="milestones">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center">
            <h2 class="section-heading text-uppercase">Milestones</h2>
            <h3 class="section-subheading text-muted">in which we attempt to apply lab concepts to the robot</h3>
          </div>
        </div>
        <div class="row">
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal5">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/m1-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			<br>
              <p class="text-muted" align = "center">we teach a robot to drive in figure-eights</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal6">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/m2-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			<br>
              <p class="text-muted" align = "center">the robot no longer crashes into walls</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal7">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/m3-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			<br>
              <p class="text-muted" align = "center">teaching a robot to (sort of) navigate</p>
            </div>
          </div>
          <div class="col-md-4 col-sm-6 portfolio-item">
            <a class="portfolio-link" data-toggle="modal" href="#portfolioModal8">
              <div class="portfolio-hover">
                <div class="portfolio-hover-content">
                </div>
              </div>
              <img class="img-fluid" src="img/portfolio/m4-thumbnail.jpg">
            </a>
            <div class="portfolio-caption">
			<br>
              <p class="text-muted" align = "center">when nothing works and life is sad</p>
            </div>
          </div>
		</div>
		</div>
    </section>
<hr class="symbol">

	<!-- Documents -->
    <section id="documents">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center">
            <h2 class="section-heading text-uppercase">Team Documents</h2>
            <h3 class="section-subheading text-muted">Non-Technical Assignments and Documentation</h3>
          </div>
        </div>
        <div class="row text-center">
          <div class="col-md-4">
            <span class="fa-stack fa-4x">
              <!--<i class="fa fa-circle fa-stack-2x text-primary"></i>
              <i class="fa fa-clock fa-stack-1x fa-inverse"></i>-->
			  <a href = "https://docs.google.com/a/cornell.edu/spreadsheets/d/1CBEvHegp8kpS_mq1MBApOBkfDOjONgkbiaCOoy79ZFw/edit?usp=sharing">
			  <img class="img-fluid d-block mx-auto" src = "img/clock.png"></a>
            </span>
            <h4 class="service-heading"><a href = "https://docs.google.com/a/cornell.edu/spreadsheets/d/1CBEvHegp8kpS_mq1MBApOBkfDOjONgkbiaCOoy79ZFw/edit?usp=sharing">Meeting Minutes</a></h4>
            <p class="text-muted">We like each other so much that we count the number of minutes we meet.</p>
          </div>
          <div class="col-md-4">
            <span class="fa-stack fa-4x">
              <!--<i class="fa fa-circle fa-stack-2x text-primary"></i>
              <i class="fa fa-laptop fa-stack-1x fa-inverse"></i>-->
			  <a href = "https://github.com/kristinanemeth/group14/raw/master/docs/Group%2014%20Team%20Contract%20(1).pdf">
			  <img class="img-fluid d-block mx-auto" src = "img/laptop.PNG"></a>
            </span>
            <h4 class="service-heading"><a href = "https://github.com/kristinanemeth/group14/raw/master/docs/Group%2014%20Team%20Contract%20(1).pdf">Team Contract</a></h4>
            <p class="text-muted">Holding each accountable so one person doesn't end up doing all the work. Oops.</p>
          </div>
          <div class="col-md-4">
            <span class="fa-stack fa-4x">
              <!--<i class="fa fa-circle fa-stack-2x text-primary"></i>
              <i class="fa fa-lock fa-stack-1x fa-inverse"></i>-->
			  <a href = "https://github.com/kristinanemeth/group14/raw/master/docs/Ethics%20Assignment%20Final.pdf">
			  <img class="img-fluid d-block mx-auto" src = "img/lock.PNG"></a>
            </span>
            <h4 class="service-heading"><a href = "https://github.com/kristinanemeth/group14/raw/master/docs/Ethics%20Assignment%20Final.pdf">Ethics</a></h4>
            <p class="text-muted">An assignment we're supposed to do.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Contact -->
    <section id="contact">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center">
            <h2 class="section-heading text-uppercase">Thanks for stopping by!</h2>
          </div>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer>
      <div class="container">
        <div class="row">
          <div class="col-md-4">
            <span class="copyright">Copyright &copy; Group 14 of ECE 3400, FA 2017</span>
          </div>
          <div class="col-md-4">
            
          </div>
          <div class="col-md-4">
            <ul class="list-inline quicklinks">
              <li class="list-inline-item">
                <a href="#">Why are you down here.</a>
              </li>
              <li class="list-inline-item">
                <a href="#">Go back up</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </footer>

    <!-- Portfolio Modals -->

    <!-- Modal 1 -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
                  <h2 class="text-uppercase">Lab 1</h2>
                  <p class="item-intro text-muted">Microcontrollers</p>
                  <h5 class = "text-left"> Materials Used </h5>
					<ul class = list-unstyled align = "left"> 
					<ul><li class = "text-left">Arduino Uno</li>
						<li class = "text-left">Continuous Parallax Servos</li>
						<li class = "text-left">1k ohm resistors</li>
						<li class = "text-left">300 ohm resistor</li>
						<li class = "text-left">Potentiometer</li>
						<li class = "text-left">Blue LED</li>
					</ul>
					<br>
				  <h5 class = "text-left">I: Introduction </h5>
				  <p class = "text-left"> Testing example code: This code is copied directly from File >> Examples >> 1.Basics >> Blink. The Arduino board includes a built-in LED light that is wired to pin 13. In the code, setup() initializes pin 13 as an output, and in loop(), the pin is repeatedly turned on (HIGH) for a second and off (LOW) for a second, thereby creating the blink effect.</p>
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/arduinoblink.png">
				  <p class = "text-left"> We were instructed to modify "Blink" code to work on an external LED light. We connected the LED to pin 11 and added a 1k ohm resistor in to prevent burning out the LED, and modified the code accordingly.</p>
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/arduinoled.png">
				  <h5 class = "text-left">II: The Serial Monitor and the Analog Pins </h5>
				  <p class = "text-left">This section provides an introduction to the six available analog pins on the Arduino Uno. First, the variable resistance of a potentiometer had to be digitally outputted on the serial monitor provided by the Arduino IDE. Second, the integer resistance values from the potentiometer had to be mapped to the LED utilizing the analogwrite() function. Third, the oscilloscope was used to analyze the PWM signal given off from the Arduino. Figure (2) shows how the potentiometer was powered as well as where a pull down resistor was placed in relevance to the rest of the circuitry. Figure (3) displays how the pull down resistor was used in reference to the LED, and the connection through digital pin 11. This connection was used as a data output from the Arduino Uno to the LED.</p>
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/connectioninterface.JPG">
				  Figure (1): The overall connection interface for this section of the lab. This includes the potentiometer, Arduino Uno, pull down resistors, and wires.
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/serialmonitorhook.png">
				  Figure (2): This is a schematic diagram for the serial monitor hookup.
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/connectingled.png">
				  Figure (3): The above diagram goes with the code in part A of the following section:
				  <p class = "text-left"><b>Analog Output</b></p>
				  <p class = "text-left"><b>A: </b>The following code was used to map the potentiometer resistance values onto the LED for variable brightness settings. This code was adopted from the previous task of displaying the potentiometer’s resistance values on the Serial Monitor. The analogRead function inputted data from the A0 pin on the potentiometer, and stored the data as integer values into the variable brightness. The information stored in the variable brightness was outputted to the LED through pin 11 (see Figure 2) utilizing the analogWrite function.</p>
				  <p class = "text-left">In addition, the integer resistance values were outputted onto the serial monitor using the Serial.println function. Another part of the code to note was that the Serial monitor was initialized by “Serial.begin(9600).”</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/analogcode.PNG">
				  
				  <p class = "text-left"><b>B: </b>We analyzed the PWM signal outputted by the Arduino on an oscilloscope. By utilizing the oscilloscope’s functionality such as the trig level and scope, the frequency of the signal was found to be 50 Hz.  Video of the PWM signal width (determined by on-off times) changing when turning the knob on the potentiometer:</p>

				  <p class = "text-left"><a href="https://www.youtube.com/watch?v=k9b29WAHjoY" target="_blank">Video of pwm signal</a></p>
				  
				  <h5 class = "text-left">III. Parallax Servos</h5>
				  
				  <p class = "text-left">Another aspect of this lab was to connect and control parallax servos using the arduinos. There was two stages to this process: an initial step of controlling the servo by writing specific values to it, and a second stage of modifying the servo based on the potentiometer.</p>
				  
				  <p class = "text-left"><b>A: </b>The circuitry setup between the arduino and the parallax servo. The servo is receiving power from the arduino  because in this case the noise would not be significant enough to affect the servo. The servo is connected directly to the arduino with the black wire connecting to GND, the red wire connecting to 5V, and the white wire connecting to A3. The pin A3 is selected due to its PWM capability, which is used to control the servo. You can view the video <a href="https://www.youtube.com/watch?v=Pr55TmeegbQ" target="_blank">here</a>.</p>
				  
				  <p class = "text-left">Additional tests run on the servo were running it at 90 and a large set of values between 0 and 180. The signal of A3 was measured with the oscilloscope and the result is depicted in Figure 4. To create this capability, we used the #servo library and the code titled pwm_servo.ino. The frequency of this was 50 Hz, with the minimum duty cycle of 7.5 and a maximum duty cycle of 12.</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/oscilloscope.jpg">
				  Figure (4): Above is the PWM measured by oscilloscope when parallax is PWM controlled by hard coded values.
				  <br>
				  <p class = "text-left"><b>B:</b> The second setup of the servo mimicked the first setup, however the PWM control was receiving data from the potentiometer rather than written values within the code. The setup was modified so that the potentiometer would output its values to A0, which would be written to ~3. Pin ~3 would be controlling the servo speed using PWM. The wiring follows figure 4. The code that controls this is pwm_servo.ino. The end result of the varying speeds dependent on the potentiometer is depicted in the following video.</p>
				  
				  <p class = "text-left"><a href="https://youtu.be/Uc2sd-4aWMA" target="_blank">Running Servo from Potentiometer</a></p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/servocode.png">
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/arduinoservo.png">
				  Figure (5): Connection between the arduino and the servo</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/wiring.jpg">
				  Figure (6): Image of wiring shown in figure 5.</p>
				  
				  <h5 id="iv-robot-autonomy" class = "text-left">IV. Robot Autonomy</h5>
				  
				  <p class = "text-left">In order to have the arduino powered without a long USB connected to it, we soldered two wires to a USB. We can use this to power the arduino with a power bank held at the bottom of the chassis. See figure (7) below:</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/solderedwires.jpeg">
				  
				  Figure (7): Shows the soldered wires for the USB port
				  
				  <p class = "text-left">Below is an image of our robot after lab 1 with chassis, servos, arduino mounted and power bank on the bottom of the chassis:</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/robot!.png">
				  
				  <p class = "text-left">It is also important to note that the servos will have to be put in two separate directions (0 and 180) in order to go in the same direction due to their orientation, seen here:</p>
				  
				  <img class="img-fluid d-block mx-auto" src = "img/lab1/servocode2.png">
				  
				  <p class = "text-left">And finally: a running robot (that goes in a straight line)! <a href="https://youtu.be/-CeEDAAQjRM" target="_blank">Yay</a>!</p>
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal 2 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
					<h2 id="lab-2">Lab 2</h2>
					
					<h3 id="objective">Objective</h3>
					
					<p class = "text-left">The purpose of this lab was to successfully implement two sensors: one would detect a 660Hz whistle blow, and the other would capture inputs from an IR sensor blinking at 7kHz; both are important components to completing the second milestone of the robot. When successfully integrated onto the robot, the robot would be able to detect the whistle blow to signify the beginning of its maze mapping, and utilize the IR sensor inputs to detect treasures.</p>
					
					<h3 id="prelab">Prelab</h3>
					<p class = "text-left">We started by adding the Open Music Lab FFT library to our Arduino IDE by putting the directory into the libraries folder of the IDE.</p>
					
					<p class = "text-left">Before doing the FFT analysis on the signal on the Arduino Board, we analyzed the signal by using an oscilloscope. A video that displays the microphone’s output connected directly to the oscilloscope is displayed <a href="https://www.youtube.com/watch?v=D_nysJqLe4c" target="_blank">here</a> .</p>
					
					<p class = "text-left">After analyzing the signal with the oscilloscope, we concluded the signal received was strong enough for FFT analysis without external amplification. Using the built fft_adc_serial code, we were able to see the FFT’s outputs from the default number of bins (FFT_N / 2 = 128). After terminating the program, we copied and pasted a single iteration of values into Excel for 660 Hz, 1320 Hz, and a control group frequency (no sound/room noise). Figure #1 displays what was graphed in Excel from these data points. We found that that the 660Hz peak was at the 4th/5th bin. As we increase the frequency of the tested sound waves, the bin number will also increase. In addition, the other test frequency of 1320Hz occured at about bin 9/10, which is double the bin number of 660Hz. This shows that our FFT analysis is working correctly. When working with the microphone, we used a web application that was recommended by the course staff: <a href="http://www.szynalski.com/tone-generator/">here</a></p>
					
					<img class="img-fluid d-block mx-auto" src="img/lab2/signalbin.png">
					Figure 1 : Signal Magnitude vs. Bin Number
					
					<h3 id="acoustic">Acoustic</h3>
					
					<p class = "text-left">The acoustic team used a Microphone connected with an Arduino Board along with FFT analysis programming in order to detect a 660 Hz signal.</p>
					
					<p class = "text-left">An Electret microphone with an attached amplifier was used in this section with the output connected to a pull up resistor with a value of 3 kOhms followed by a polarized capacitor with a value of 1 microFarad.  The capacitor then acts as a high pass filter preventing lower frequencies from passing through the circuit by blocking DC current when charging, and letting through AC current. This works because a capacitor has a varying impedances dependent on the frequency, so lower frequencies have a large resistance when trying to pass. The resistor in parallel is used in this case to create a path of lower resistance that the low frequency signals will take. 
					This microphone is a passive sensor device that uses the energy provided by the beating of the membrane to power up an inductor. The amplifier included in the internal microphone circuitry was in the form of a MA4466 chip.</p>
					
					<p class = "text-left">Since the circuitry and amplifier were already integrated into the Electret Capsule microphone circuitry, we just had to connect the microphone’s three pins to the Arduino. The VCC, GND, and OUT pins on the microphone were connected to the +5 volts, GND, and A0 pins respectively on the Arduino. After we connected the microphone, fast fourier transforms were utilized, specifically in the modified fft_adc_serial program, to distinguish a 660 Hz signal from room noise along with 585 and 735 Hz signals.</p>
					
					<p class = "text-left">Based on our previous FFT_anaylsis (see Figure #1), we concluded that bins 4 and 5 represented maximum bin values in a 660 Hz signal. Therefore, we monitored the succession of bins 4 and 5 occurring as maximums in the program. From keeping track of the indices of the FFT maximums, we blinked an LED every time a balance of bins 4 and 5 were received from the FFT analysis.</p>
					
					<p class = "text-left">A demo was performed in which a LED shined only when 660 Hz was detected. A video showing the effects on the LED with 585 Hz vs 660 Hz vs 735 Hz is shown <a href="https://www.youtube.com/watch?v=yrrrwozsazk" target="_blank">here</a> .</p>
					
					<p class = "text-left">Here is our modified fft_adc_serial (from the examples) code for 660Hz Detection:</p>
					<pre class="highlight"><code style="text-align:left"><ul>    
for (byte i = 0 ; i &lt; FFT_N/2 ; i++) {
   //If the value of this bin number is greater than the current maximum,     
   //store the value in maximum and the bin number in index.
   if (fft_log_out[i] &gt; maximum) {
    	maximum = fft_log_out[i];
    	index = i;
   }

   if (i == 127) {  //Checks what the maximum bin number was at the last bin  
                  	//(FFT_N/2 - 1)

   if (index == 4) {  	//Increment start1
           start1++;
        }

   if (index == 5) {  	//Increment start2
      start2++;}

   if (start1 == 20){  //Too many bin 4's indicate a 585 Hz Signal. Reset  
                   //Start2.
      start2 = 0;
   }

   if (start2 == 20) {	//Too many bin 5's indicate a 735 Hz Signal. Reset
                    //Start1.
      start1 = 0;     	 
    }
 	 
    if (start1 &gt; 3 &amp;&amp; start2 &gt; 2)	//A balance of bin 4's and 5's indicate a 
                                //660 Hz Signal. Shine the LED.
    {
        digitalWrite(10, HIGH);
        delay (1000);
        digitalWrite(10, LOW);
        }

    if (index != 4 &amp;&amp; index != 5) {   //Resets both incrementers
      start_time = 0;
      start1 = 0;
      start2 = 0;
    }
    maximum = 0; //resets maximum checking at the end of the loop
    index = 0; //resets the index at which a maximum occurs at the end of
               	//the loop
    }
}</ul>
</code></pre>
					
					<h3 id="optical">Optical</h3>
					
					<p class = "text-left">Our IR system for light frequency detection consisted of an Arduino with a specialized program (see code below), a LM358 op amp for amplification, and our Phototransistor circuit.</p>
					
					<p class = "text-left">Our op-amp was designed according to Figure #2. By selecting R1 to be a 20K resistor and R2 to be a 10K resistor we were able to achieve a voltage gain of 3x.</p>
					
					<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab2/OpAmp.png">
					<img class="img-fluid d-block mx-auto" src="img/lab2/invertingopamp.gif"></p>
					
					<p class = "text-left">Figure 2 : (image courtesy of http://ecetutorials.com/analog-electronics/inverting-and-non-inverting-amplifiers/ 
					Op-amp Pinout from the LM358 documentation:
					http://www.ti.com/lit/ds/symlink/lm258a.pdf)</p>
					
					<p class = "text-left">In order to test our IR system’s ability to detect the three different treasure frequencies, we connected three different leds to our Arduino. One LED shined when 7kHz was detected, another LED shined when 12 kHz was detected, and a third LED shined when 17 kHz was detected. Only one LED shined at a time and the detection range was about half of a foot.</p>
					
					<p class = "text-left">A demo with the LED configuration described above is shown in the following video:</p>
					
					<p class = "text-left"><a href="https://www.youtube.com/watch?v=DN9lzJqB21Q" target="_blank">here</a>.</p>
					
					<p class = "text-left">The light frequency outputted from the treasure was manipulated by hooking up the positive and negative headers below the potentiometer to an oscilloscope. The oscilloscope monitored the frequency and amplitude of the signal as we turned the potentiometer with a screw driver.</p>
					
					<p class = "text-left">Below is our modified fft_adc_serial code for Treasure Signal Detection:</p>
					<pre><code style="text-align:left"><ul>
for (byte i = 0 ; i &lt; FFT_N/2 ; i++){<ul>
if (fft_log_out[i] &gt; maximum - 5) {
  if (i &gt; 5)
    //Bin numbers less than five tend to be maximums for  
    //treasure signals. Therefore we cut them out for easier
    //signal detection.
    {
    maximum = fft_log_out[i];
    index = i;
    }
}
if (i == 127) { //Checks what the maximum bin number was at the last bin  
  		//(FFT_N/2 - 1)
  if (index == 45 || index == 46 || index == 47) {  	//7K
  	start1++;
  	//Shine LED from Digital Pin 8 if the bin numbers for 7K are       
  	//detected for at least 5 iterations.
  	if (start1 &gt; 5) {
  	  digitalWrite(8, HIGH);
  	  delay (1000);
  	  digitalWrite(8, LOW);
	}
    }
    //If the maximum didn't occur at the above indices, reset the increment  
    //variable start1 to 0
	else {
	  start1 = 0;
	}

	if (index == 79 || index == 80 || index == 81) {  	//12K
	  start2++;
	  //Shine LED from Digital Pin 9 if the bin numbers for 12K are 
	  //detected for at least 5 iterations.
	if (start2 &gt; 5) {
		digitalWrite(9, HIGH);
		delay (1000);
		digitalWrite(9, LOW);
	}
	}

  //If the maximum didn't occur at the above indices, reset the increment 
  //variable start2 to 0
	else {
	  start2 = 0;
	}

	if (index == 113 || index == 114 || index == 115) {  	//17K
	  start3++;
	  //Shine LED from Digital Pin 10 if the bin numbers for 17K are 
	  //detected for at least 5 iterations.
	if (start3 &gt; 5) {                                 	 
		digitalWrite(10, HIGH);
		delay (1000);
		digitalWrite(10, LOW);        	 
	}
	}
  //If the maximum didn't occur at the above indices, reset the increment 
  //variable start3 to 0
	else {
	  start3 = 0;
	}
	
maximum = 0; //resets maximum checking at the end of the loop
index = 0; //resets the index at which a maximum occurs at the end of 
		//the loop
}
</ul>
}</pre>
</code> 
					
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal 3 -->
    <div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->      
				  <h2 id="lab-3">Lab 3</h2>

<h3 class = "text-left" id="objectives">Objectives</h3>
<p class = "text-left">Graphics: Take external inputs to the FPGA and display them on a screen. This is the beginning of our “maze” 
Acoustics: Take a external input to the FPGA and generate a short ‘tune’ consisting of at least three tones to a speaker via an 8-bit DAC.</p>

<h3 class = "text-left" id="acoustic-team">Acoustic Team</h3>
<p class = "text-left">(Giacomo, Kristina)</p>

<h3 class = "text-left" id="materials">Materials:</h3>
<ul class = "text-left">
  <li>Lab Speaker</li>
  <li>8-bit R2R DAC</li>
  <li>3.5 mm auxiliary jack</li>
</ul>

<h3 class = "text-left" id="square-wave">Square Wave</h3>
<p class = "text-left">The initial part of the lab that we implemented was using the FPGA to generate a square wave. We selected a frequency of 440Hz for the square wave and connected this output to GPIO pin 0 because it was not previously in use. The following code was used to implement the square wave along with the addition of the counter and CLKDIVIDER_440 to the initial section of the code with parameter declarations. For the wiring, we used a breadboard and connected the GPIO pin to the two data pins on the phone jack socket. Additionally, we soldered the two side pins together to increase ease of use. The sound generated and the setup is shown in the <a href="https://www.youtube.com/watch?v=MgeT1byl4v8&amp;feature=youtu.be" target="_blank">here</a>. The square wave generated is shown in the picture below.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
always @ (posedge CLOCK_25) begin
	if(counter == 0) begin
		counter &lt;= CLKDIVIDER_440 - 1;
		square_440 &lt;= ~square_440;
	end
	else begin
			counter &lt;= counter - 1;
			square_440 &lt;= square_440;
	end
end</ul>
</code></pre></div></div>
<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab3/squarewave.JPG" alt="Square Wave" /></p>

<h3 class = "text-left" id="sin-wave">Sin Wave</h3>
<p class = "text-left">The next phase we decided to implement was a single sine wave to generate a better clearer sounding tone. To implement this we needed to use an 8-bit R2R DAC because the output from the FPGA to the speaker is not longer one of two values as with the square wave. We wire the inputs from GPIO pins to pins 1-8 of the DAC and then connected pin 16 of the DAC to the speaker input. This wiring setup is depicted in the following picture.
<img class="img-fluid d-block mx-auto" src="img/lab3/audiosetup.JPG" alt="FPGA Setup" /></p>

<p class = "text-left">Then we wrote the following code to implement the sin wave.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
reg [7:0] sine[0:255];
reg [10:0] counter1;
   
initial
     	Begin
sine[0] &lt;= 8'd100;
sine[1] &lt;= 8'd102;
	//remaining sin table values
	sine[255] &lt;= 8'd98;

     end

     assign GPIO_1_D[8] = q[7];
     assign GPIO_1_D[10] = q[6];
     assign GPIO_1_D[12] = q[5];
     assign GPIO_1_D[14] = q[4];
     assign GPIO_1_D[16] = q[3];
     assign GPIO_1_D[18] = q[2];
     assign GPIO_1_D[20] = q[1];
     assign GPIO_1_D[22] = q[0];

always @ (posedge CLOCK_25) begin
             if (counter1 == 127 ) begin
                    counter1 &lt;= 0;
                    q  &lt;=  sine[ADDR];
                    if (ADDR == 255)
                            ADDR &lt;= 0;
                    else
                            ADDR &lt;= ADDR + 1;
             end
             else
                    counter1 &lt;= counter1 + 1;    
end</ul>
</code></pre></div></div>
<p class = "text-left">The code was set up so that a counter would control the selection of the values in a sin table the output that corresponding value to create a sin graph. We used a counter that  would increment continuously with the clock frequency of 25MHz, and once the counter reached the value of 127 it would restart. This counter was used to determine when to increment the ADDR, specifically when the counter would reach the value of 127. We selected this value as when it included 0 there are 128 total values in order to produce a audible sine wave through the speakers. The incrementation of the counter was implemented with an if statement, and the incrementation of ADDR used an embedded if statement.  To implement the sin table for use we used direct digital synthesis. We decided to create a sin table outside of verilog for convenience. We implemented this in Matlab using the following code then copied and pasted into our project. We chose to create a sin table of one period with 256 plotted values because the number corresponds easily to the values of the 8-bit DAC. To ensure that our table was correct we graphed the values. The 8 separate GPIO pins were set to output corresponding to each input on the DAC. The GPIO pins were selected because they were previously not in use. See the video of the sin wave producing a sound<a href="https://www.youtube.com/watch?v=-vzeRQowzgA" target="_blank">here</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
total = 255;
for t = 0:total 
 	   value = round(100*sin((6.283*t)/total)+100);
  	  values(t) = value;
  	  fprintf('sine[%d] &lt;= 8''d%d;\n',t, value)
end</ul>
</code></pre></div></div>
<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab3/sinwave.JPG" alt="Sin Wave" /></p>

<h3 class = "text-left" id="tri-tone">Tri Tone</h3>
<p class = "text-left">To implement the tri tone, we decided to use three tones given by sin waves with different frequencies to create this. To implement this we used a setup similar to the code for the sin wave and repeated a similar version of the sin code three times. To cycle through these tones we implemented a finite state machine. The transition between each of the states, we wait until one second passes dependent on the clock cycle to move onto the next state. The wiring setup between the FPGA, to the DAC, to the speaker is the same as the setup for the individual sin wave. Our finite state machine is shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
always @ (posedge CLOCK_25) begin
     next_state = 2'b00;
     case(state)
   	 TONE1: if (tone_length == ONE_SEC) begin
   				 next_state = TONE2;
   				 tone_length = 0;
   		 	end
   			  else begin
   				 next_state = TONE1;
   				 tone_length = tone_length + 1;
   			  end
   	 TONE2: if (tone_length == ONE_SEC) begin
   				 next_state = TONE3;
   				 tone_length = 0;
   			  end
   			  else begin
   				 next_state = TONE2;
   				 tone_length = tone_length + 1;
   			  end
   	 TONE3: if (tone_length == ONE_SEC) begin
   				 next_state = TONE1;
   				 tone_length = 0;
   			  end
   			  else begin
   				 next_state = TONE3;
   				 tone_length = tone_length + 1;
   			  end
   	 default: next_state = TONE1;
     endcase
end

always @ (posedge CLOCK_25) begin
    state &lt;= next_state;
end

always @ (posedge CLOCK_25) begin
    
     ///// TONE 1 //////
     if (state == TONE1) begin
   	  if (counter1 == 127 ) begin
   		 counter1 &lt;= 0;
   		 q  &lt;=  sine[ADDR];
   		 if (ADDR == 255)
   			 ADDR &lt;= 0;
   		 else
   			 ADDR &lt;= ADDR + 1;
   	  end
   	  else
   		 counter1 &lt;= counter1 + 1;
      end
      
      ///// TONE 2 ////
      if (state == TONE2) begin
   	  if (counter1 == 255 ) begin
   		 counter1 &lt;= 0;
   		 q  &lt;=  sine[ADDR];
   		 if (ADDR == 255)
   			 ADDR &lt;= 0;
   		 else
   			 ADDR &lt;= ADDR + 1;
   	  end
   	  else
   		 counter1 &lt;= counter1 + 1;
      end         
      
      ///// TONE 3 /////
      if (state == TONE3) begin
   	  if (counter1 == 511 ) begin
   		 counter1 &lt;= 0;
   		 q  &lt;=  sine[ADDR];
   		 if (ADDR == 255)
   			 ADDR &lt;= 0;
   		 else
   			 ADDR &lt;= ADDR + 1;
   	  end
   	  else
   		 counter1 &lt;= counter1 + 1;
      end    
      
end</ul>
</code></pre></div></div>
<p class = "text-left">The video of the implemented tri tone waves can be seen <a href="https://www.youtube.com/watch?v=4RYInz8DY74">here</a>. The video of the tri tone sound can be seen <a href="https://www.youtube.com/watch?v=qpzVlRkj_Dc" target="_blank">here</a>.</p>

<h3 class = "text-left" id="graphics">Graphics</h3>
<p class = "text-left">(Russell, Michelle, Joan)</p>

<h3 class = "text-left" id="materials-1">Materials</h3>
<ul class = "text-left">
  <li>1 VGA screen</li>
  <li>1 VGA cable</li>
  <li>1 VGA connector</li>
  <li>1 VGA switch</li>
  <li>Various resistors</li>
</ul>

<p class = "text-left">Our team decided to sequentially divide our work into four portions. The first task was to display the logic levels of two input switches on the FPGA board to four LEDs on the FPGA board. Second, the logic levels of two input switches on the FPGA board would be displayed to the computer screen. Third, the code would be modified to save memory space and be able to display a “map” later on in the semester.  Last, outputs from the Arduino Uno would be displayed onto the computer screen.</p>

<p class = "text-left"><strong>A: Switches to LED lights on the FPGA board</strong></p>

<p class = "text-left">We implemented a finite state machine that would check if the current “gridarray” coordinate matched that of the inputs and would save a 1 to that register accordingly.  Next, the machine go to state_0 and increment the “gridarray” coordinates. <a href="https://youtu.be/ve1l59f2dZU">Here</a> is our code working.</p>

<p class = "text-left">Here is the code for this part:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
if (state==1'b1) begin //switch input
	//led_counter &lt;= 25'b0;
	if( grid_coord_y == highlighted_y &amp;&amp; grid_coord_x == highlighted_x) begin
		gridarray[grid_coord_x][grid_coord_y] &lt;= 1'b1;
	end
				
	else begin
		gridarray[grid_coord_x][grid_coord_y] &lt;= 1'b0;
end
				
	state &lt;= 1'b0;		
end
		  
if(state==1'b0) begin //increment grid index
	if (grid_coord_x == 1'b0 &amp;&amp; grid_coord_y == 1'b0) begin
		grid_coord_x &lt;= 2'b00;
		grid_coord_y &lt;= 2'b01;
	end
			
	else if (grid_coord_x == 1'b0 &amp;&amp; grid_coord_y == 1'b1) begin
		grid_coord_x &lt;= 1'b1;
		grid_coord_y &lt;= 1'b0;
	end
				
	else if (grid_coord_x == 1'b1 &amp;&amp; grid_coord_y == 1'b0) begin
		grid_coord_x &lt;= 1'b1;
		grid_coord_y &lt;= 1'b1;
	end
				
	else begin
		grid_coord_x &lt;= 1'b0;
		grid_coord_y &lt;= 1'b0;
	end

	// led_state   &lt;= led_state;
	//led_counter &lt;= led_counter + 25'b1;
	state &lt;= 1'b1;		  
end</ul>
</code></pre></div></div>
<p class = "text-left"><strong>B: Switches on FPGA board to computer screen grid</strong></p>

<p class = "text-left">In the second part, instead of outputting to LED lights, we outputted to four pins on the FPGA board (GPIO_0_D ). These GPIO pins were used in controlling the colored square on the screen. Here is a video demonstrating the changing position of the square based on switch logic levels:</p>

<p class = "text-left">https://www.youtube.com/watch?v=1_f9FdkPpto target="_blank"</p>

<p class = "text-left">In this part of the lab we used an 8-bit DAC which converted the signals from the FPGA board to analog signals between 0 and 1 V.  The digital pixel information to be transmitted from the FPGA consisted of 3-bits specifying the red color, 3-bits specifying the green color and 2-bits to specifying the blue color. When all 8 bits are 1’s, the DAC will essentially read these digital signals as three 1 V signals ( and the VGA screen will display white). For the 3-bit colors, the first bit is the more “significant” because it represents a number of higher order ( 22) whereas the last bit represents a number of lower order ( 20). To account for this, we want to choose resistor values which would add more “weight” to the first bit. Essentially, when the most significant bit is 1, we want the output to be 4/7 V.  Internal resistance of the VGA display is 50 ohms. The FPGA outputs 3.3V.</p>

<p class = "text-left">Calculate resistance R for most significant bit of 3 bits:</p>

<p class = "text-left">4/7 V= 3.3V * 50/(50+R)  ⇒        R= 238.75 Ohms</p>

<p class = "text-left">Similarly, the resistance needed for the second most significant bit is 527.5 Ω and the resistance needed for the least significant bit is 1105 Ω.</p>

<p class = "text-left">For the 2-bit color ( blue), the resistance for the most significant bit is 197.5 Ω and the resistance for the least significant bit is 445 Ω.</p>

<p class = "text-left">It should be noted that resistors were already chosen and soldered into the DAC we used to complete this lab.</p>

<p class = "text-left"><strong>C: Saving Memory</strong></p>

<p class = "text-left">In order to make our program more efficient and adaptable for future uses (e.g. more grid spaces with images), we decided to implement a double “for” loop that sequenced over a two dimensional memory array. The two dimensional array was initialized as a register named “gridscreen” storing eight bit values as shown in our merged code. Each element in “gridscreen” contained 8 bits in order to properly store the 8 bit data representations of the pixel colors. 

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
always @ (posedge CLOCK_50) begin</p>
   if(gridarray[0][0] == 1'b1) begin
   	gridscreen[0][0] = 8'b000_111_00; //green
   	gridscreen[0][1] = 8'b000_000_11; //blue
   	gridscreen[1][0] = 8'b111_000_00; //red
   	gridscreen[1][1] = 8'b111_000_11; //purple
   end
   	 
   else if (gridarray[0][1] == 1'b1) begin
   	gridscreen[0][0] = 8'b111_000_11; //purple
   	gridscreen[0][1] = 8'b000_111_00; //green
   	gridscreen[1][0] = 8'b000_000_11; //blue
   	gridscreen[1][1] = 8'b111_000_00; //red
   end
   	 
   else if (gridarray[1][0] == 1'b1) begin
   	gridscreen[0][0] = 8'b111_000_00; //red
   	gridscreen[0][1] = 8'b111_000_11; //purple
   	gridscreen[1][0] = 8'b000_111_00; //green
   	gridscreen[1][1] = 8'b000_000_11; //blue
   end
   	 
   else begin
   	gridscreen[0][0] = 8'b000_000_11; //blue
   	gridscreen[0][1] = 8'b111_000_00; //red
   	gridscreen[1][0] = 8'b111_000_11; //purple
   	gridscreen[1][1] = 8'b000_111_00; //green
   end
   	 
   PIXEL_WIDTH = 10'd16;
   PIXEL_HEIGHT = 10'd16;
   if ((PIXEL_COORD_X &lt; 2 * PIXEL_WIDTH) &amp;&amp; (PIXEL_COORD_Y &lt; 2 * PIXEL_HEIGHT)) begin
   	for (i = 10'd0; i &lt;= 10'd1; i = i + 10'd1) begin
   		for (j = 10'd0; j &lt;= 10'd1; j = j + 10'd1) begin
   			if(((j * PIXEL_WIDTH &lt; PIXEL_COORD_X) &amp;&amp; (PIXEL_COORD_X &lt; (j + 10'd1) * PIXEL_WIDTH)) &amp;&amp; ((i * PIXEL_HEIGHT &lt; PIXEL_COORD_Y) &amp;&amp; (PIXEL_COORD_Y &lt; (i + 10'd1) * PIXEL_HEIGHT))) begin
   				PIXEL_COLOR = gridscreen[j][i];
   			end		 
   		end	 
   	end
   end
   	 
   else begin
   	PIXEL_COLOR = 8'b000_000_00;
   end	 
end</ul>
</code></pre></div></div>
<p class = "text-left">The four beginning control blocks decide which colors will be stored in each individual grid space. Since the current objective was a 2x2 grid, four different colors were stored in a top left, top right, bottom left, and bottom right grid space. The widths and heights of these grid spaces were defined right before the double for loop.</p>

<p class = "text-left">In order to understand the functionality of the double for loop method that was implemented, several points must be made:</p>

<p class = "text-left">Each index “i” or “j” corresponds to a grid space in the same fashion as the indexes in “gridscreen.” In this way, the register PIXEL_COLOR can be assigned to the color information stored inside “gridscreen” at those indexes. 
The current index “i” or “j” is multiplied by the height and width of each grid space respectively in the if statement. This is to define the bounds of the space that is being colored in at the current iteration of the for loop.
Since the “j” for loop is inside the “i” for loop, the grid spaces are colored in across the screen until the last grid space is reached in the x direction. Then the process repeats, but at a “PIXEL_HEIGHT” lower than the previous row. 
The qualifying if-else statement that is a scope above the double for loop defines all the pixels in the screen that aren’t being used, and colors them in a default color (“PIXEL_COLOR = 8’b000_000_00 //black”).</p>

<p class = "text-left">A more common approach to this problem consisted of using case statements to define the widths and heights for each grid space, and then assigning each element of the memory array to each grid space. The double for loop method was picked over this implementation for the purposes of more code efficiency and adaptability. The double for loop method was more efficient because only several lines of code were written, when dozens of case statements would have been needed for the case statement method.</p>

<p class = "text-left">Moreover, if a 10x10 grid was drawn, only the code in the control blocks from the beginning of the code would need to be expanded upon. It would not be necessary to add lines of code to the bodies of the for loops. We would only need to change the variables “i”, “j”, “PIXEL_WIDTH”, and “PIXEL_HEIGHT” in most cases.</p>

<p class = "text-left">The adaptability of this code will be helpful when displaying a maze for the final competition. The memory arrays can be easily updated to display image files instead of colors and several control statements can be added inside the body of the double for loop in order to identify and display which grid space the robot is located in real time.</p>

<p class = "text-left">The efficiency of the code will mitigate potential screen latency in the final competition when displaying the robot’s location on the screen. This is because our simplified iterative system consists of a lower amount of data storages and calculations, conserving memory and computational power.</p>

<p class = "text-left"><strong>D. Arduino to FPGA to Screen</strong></p>

<p class = "text-left">In the final part of the lab, we had to connect the Arduino Uno to the FPGA board. To do this, we connected two external switches (and used a 1.2k pullout resistor) to the Arduino Uno and connected the Arduino Uno to the FGPA board. Since the robot’s primary controller is the Arduino, the eventual plan is to have the Arduino process the maze, send the data to the FGPA, which will then project it onto the VGA screen. The switches were connected to digital pins of the Arduino board and their signals sent to the FPGA course; our code is shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>
const int buttonPin1 = 10;
const int buttonPin2 = 11;
const int buttonPin1out = 2;
const int buttonPin2out = 7;
int buttonState1 = 0;
int buttonState2 = 0;    

void setup() {
  Serial.begin(9600);
  pinMode(buttonPin1, INPUT);    
  pinMode(buttonPin2, INPUT);  
  pinMode(buttonPin1out, OUTPUT);    
  pinMode(buttonPin2out, OUTPUT);
}     

void loop(){
  buttonState1 = digitalRead(buttonPin1);
  buttonState2 = digitalRead(buttonPin2);
  digitalWrite(buttonPin1out, buttonState1);
  digitalWrite(buttonPin2out, buttonState2);
  Serial.println(buttonState1);
  Serial.println(buttonState2);
}</ul>
</code></pre></div></div>
<p class = "text-left">The Arduino has an output of 5V and the FPGA receives 3.3V signals – thus, a voltage divider was needed to regulate the voltage. We used this setup below and used resistor values of 50 and 100.</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab3/voltagedivider.PNG" alt="image" /></p>

<p class = "text-left">We then had to connect the Arduino outputs to the GPIO (31 and 33) pins of the FPGA board. Once completed, we connected the FPGA to the VGA screen and tested the switches. This was our final setup:</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab3/arduinofpga.PNG" alt="image2" /></p>

<p class = "text-left">Our video is <a href="https://www.youtube.com/watch?v=bx4GTp5HWR8">here</a>.</p>
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal 4 -->
    <div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
                        <h2 id="lab-4">Lab 4</h2>

<h3 class = "text-left" id="objectives">Objectives</h3>

<p class = "text-left">For this lab, we had to implement radio communication between the Arduino and FPGA.</p>
<h3 class = "text-left" id="radio-team">Radio Team</h3>
<p class = "text-left">Russell, Giacomo</p>

<h4 class = "text-left" id="materials">Materials</h4>
<ul class = "text-left">
  <li>2 Nordic nRF24L01+ transceivers</li>
  <li>2 Arduino Unos (one must be shared with the other sub-team)</li>
  <li>2 USB A/B cables</li>
  <li>2 radio breakout boards with headers</li>
</ul>

<p class = "text-left">The example code provided an implementation of RF that would transmit the current time using the millis() function. The time value was sent on the transmitting end through the use of the radio.write() function. This value was received on the other Arduino through the use of the radio.read() function.</p>

<p class = "text-left">We replaced the “got_time” variable that represented the time value in the example code with another unsigned long variable. This unsigned long variable would be used to send over coordinates in the later parts of this lab.</p>

<p class = "text-left">Instead of sending the entire maze wirelessly for each iteration at the end of the Arduino’s loop delay, we decided to only send the current coordinates’ x and y values. We represented the coordinate as a two digit number with the y value first and the x value second in the transmitting Arduino. For example, if we were to transmit the current coordinate (2,3), we would transmit 32. We thought that sending individual tile data would be better than sending the whole maze array as it reduces the number of packets between the transmitting and receiving arduinos for every “move” that our robot makes.</p>

<p class = "text-left">On the receiving end, this two digit number would be converted back to an individual x and value through the use of the following lines:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style='text-align:left'><ul>   
int x = recieved_x_variable % 10   //The remainder is the least significant digit 
int y = recieved_y_variable / 10   //The divisor is the most significant digit
</ul></code></pre></div></div>

<p class = "text-left">Once individual x and y values were extracted, we converted them into bit values which is explained in the maze communication section. The bit values would determine the digital outputs that would send the information parallely to the FPGA. For example, if x = 2 and y = 3, x would be set to 2’b10 and y would be set to 3’b011. Next, the digital pins corresponding to the most significant bit in the x value and 2 least significant bits in the y values would be set to HIGH, and the rest of the digital pins would be set to LOW.</p>

<h3 class = "text-left" id="fpga-team">FPGA Team</h3>
<p class = "text-left">Michelle, Kristina, Jo</p>

<h4 class = "text-left" id="materials-1">Materials</h4>
<ul class = "text-left">
  <li>Arduino Board</li>
  <li>DE0-NANO Board</li>
  <li>VGA Cable</li>
  <li>VGA Switch</li>
  <li>Various resistors</li>
</ul>

<p class = "text-left">We updated our Verilog code from Lab 3 to display a 4 by 5 grid array instead of a 2 by 2 grid array. This was done by expanding upon the memory locations so that all of the grid’s 20 squares can be accounted for with their respective colors.</p>

<p class = "text-left">The code displayed below shows how we assigned pixel colors to all of gridscreen’s square areas.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>    
if (rdy == 0) begin
    gridscreen[0][0] = 8'b111_000_00;
    gridscreen[0][1] = 8'b111_000_00;
    gridscreen[0][2] = 8'b111_000_00;
    gridscreen[0][3] = 8'b111_000_00;
    gridscreen[0][4] = 8'b111_000_00;
    
    gridscreen[1][0] = 8'b111_000_00;
    gridscreen[1][1] = 8'b111_000_00;
    gridscreen[1][2] = 8'b111_000_00;
    gridscreen[1][3] = 8'b111_000_00;
    gridscreen[1][4] = 8'b111_000_00;
    
    gridscreen[2][0] = 8'b111_000_00;
    gridscreen[2][1] = 8'b111_000_00;
    gridscreen[2][2] = 8'b111_000_00;
    gridscreen[2][3] = 8'b111_000_00;
    gridscreen[2][4] = 8'b111_000_00; 
    
    gridscreen[3][0] = 8'b111_000_00;
    gridscreen[3][1] = 8'b111_000_00;
    gridscreen[3][2] = 8'b111_000_00;
    gridscreen[3][3] = 8'b111_000_00;
    gridscreen[3][4] = 8'b111_000_00;
    rdy = 1;
end</ul>
</code></pre></div></div>

<p class = "text-left">The “rdy” bit was used to initialize the grid array. By initializing the grid array, we could avoid flickering blocks on the screen which signified that the Verilog Code was setting two colors at once on one grid square area. The rdy bit was initialized to 0 towards the top of our code so that the if statement would evaluate to true the first time. Once all the grid squares were set in “gridscreen” the rdy bit was set to 1 so that the grid array wouldn’t be initialized again.</p>

<p class = "text-left">We iterated through this memory area with double for loop taken from Lab 3’s implementation. Only the maximum values for variable “i” and “j” were changed in the double for loop as well as the “PIXEL_WIDTH” and “PIXEL_HEIGHT” for larger squares. This part of the implementation was scarcely changed because the iteration can set the square colors in a grid array of any arbitrary size.
The code for this iteration is shown below:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>
PIXEL_WIDTH = 10'd64;
PIXEL_HEIGHT = 10'd64;
  if ((PIXEL_COORD_X &lt; 4 * PIXEL_WIDTH) &amp;&amp; (PIXEL_COORD_Y &lt; 5 * PIXEL_HEIGHT)) begin
    for (i = 10'd0; i &lt;= 10'd4; i = i + 10'd1) begin
	    for (j = 10'd0; j &lt;= 10'd3; j = j + 10'd1) begin
		    if(((j * PIXEL_WIDTH &lt; PIXEL_COORD_X) &amp;&amp; (PIXEL_COORD_X &lt; (j + 10'd1) * PIXEL_WIDTH)) &amp;&amp; ((i * PIXEL_HEIGHT &lt; PIXEL_COORD_Y) &amp;&amp; (PIXEL_COORD_Y &lt; (i + 10'd1) * PIXEL_HEIGHT))) begin
			    PIXEL_COLOR = gridscreen[j][i];
		    end		 
	    end	 
    end
  end
 
  else begin
    PIXEL_COLOR = 8'b000_000_00;
  end	</ul>
</code></pre></div></div>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab4/4by5.jpeg" alt="4by5" /></p>

<p class = "text-left">We next had to implement some communication system between the Arduino and the FPGA board. Our first attempt was for an SPI system: we coded the Arduino to send 5-bit dummy robot coordinates via digital pins (2 bits for the x coordinates, 3 bits for the y coordinate), and tested its functionality with the oscilloscope. A picture of its output is shown below for output (1, 1):</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab4/lab4oscilloscope.jpeg" alt="oscilloscope" /></p>

<p class = "text-left">Our code for the FPGA is shown below:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>    
always @ (posedge SPI_CLK) begin
    if(CS == 0 &amp;&amp; rf == 0) begin

    for (i = 8'd0; i &lt;= 8'd4; i = i + 8'd1) begin
  	    datain[i] = MOSI;
  	    rf = 1'b1;
    end

    //parsing
    //grid_coord_x = datain[4:3];
    //grid_coord_y = datain[2:0];
    //grid_coord_x = 4'd2;
    // grid_coord_y = 5'd3;
    rf = 1'b0;
      end
end</ul>
</code></pre></div></div>
<p class = "text-left">We abandoned our attempt at SPI after we ran into problems debugging. Instead, we implemented parallel communication between the Arduino and the FPGA board due to time constraints and our unfamiliarity with SPI protocol. Additionally, the Arduino pins required for the RF module utilized the same pins as that of the SPI, so instead of using a multiplexer or some other form of hardware solution for this, we decided to implement the parallel communication.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>
always @ (posedge CLOCK_50) begin
   	x1 = GPIO_0_D[25];
   	x2 = GPIO_0_D[24];
   	y1 = GPIO_0_D[27];
   	y2 = GPIO_0_D[26];
   	y3 = GPIO_0_D[31];
end</ul>
</code></pre></div></div>

<p class = "text-left">In order to communicate information from the Arduino to the FPGA, we choose to implement a parallel implementation over SPi or I2C. This was by converting the x and y values on the receiving RF Arduino into bit values. The x values had two bits associated with them (the robot can only be at x coordinates from 0 to 3, therefore there are 4 possible options - 00, 01, 10, 11). The  y values had three bits associated with them (the robot can only be at y coordinates from 0 to 4, therefore there are 5 possible options - 00, 01, 10, 11, 100). 
We needed to use voltage dividers (of values of 100 and 50) for each of the bits corresponding to the x.  S photo of our setup is below:</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab4/lab4setup.jpeg" alt="lab4setup" />.</p>

<p class = "text-left">The robot was simulated to move across the screen back and forth in the x directions. Once a side was reached, the simulated robot would move one space down the screen. Once the final grid space has been reached (bottom right corner of the grid), the simulated robot would reset itself at (0,0)</p>

<p class = "text-left">Here is a video of the serial monitor displaying the new coordinates of the simulated robot that are sent to the fpga to be displayed on the screen:</p>

<p class = "text-left"><a href = "https://www.youtube.com/watch?v=iMkuTcneBeA" target="_blank">Video</a></p>

<p class = "text-left">Based on the new x coordinate and y coordinate of the simulated robot, the memory array for the grid was updated to store the color green into the current grid square. Once a grid square was colored green, it would be set to blue to indicate that the area has already been explored. If the robot was to reach an explored area again, the area would turn green indicating the robot’s position regardless of whether the grid square was explored or not. 
The following picture displays the grid for the initial position of the simulated robot which is (0,0). The green square displays the starting area of the robot and the red squares display unexplored areas for the simulated robot.</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/lab4/greensquare.jpeg" alt="image" /></p>

<p class = "text-left">While we did not have the chance to test this section of the code due to the previous issues, we wrote out the following code to so that the previously visited locations would turn blue. To implement this we would save the location to two registers, then this register would be used in the next cycle after the new current location had been updated to change the location to blue. The following is the write out of the code.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>
   gridscreen[lastsquare_x][lastsquare_y] = 8'b000_000_11;
   lastsquare_x = grid_coord_x;
   lastsquare_y = grid_coord_y;</ul>
</code></pre></div></div>

<p class = "text-left">The actual grid is not updating correctly. The radio is set up to snake through the grid: it would start at (0,0), move right 3 coordinates, move down 1 coordinate, move left 3 coordinates, etc, of which the grid is not updating correctly. A video of our current result is shown below; we have not yet finished debugging the code:</p>

<p class = "text-left"><a href="https://youtu.be/67F9fmcdOR8" target="_blank">Attempt 1</a></p>

<p class = "text-left"><a href="https://youtu.be/riq3GrkjOTQ" target="_blank">Attempt 2</a></p>

<p class = "text-left"><a href="https://youtu.be/VIkMuR-udGA" target="_blank">Attempt 3</a></p>

<p class = "text-left">We ran into many bugs when attempting to implement the grid. The initial problem we faced was flickering squares between red and green when trying to display the grid. We fixed this issue by implementing the previously described ready bit so that the initial grid would be displayed every cycle. After this point the grid was displaying properly however there were inconsistent values of “visited” blocks that would show up on the grid. One potential cause we found was that the values on the arduino and FPGA code were left floating so they could have been incrementing intermittently. We fixed this issue by initializing the values both on the arduino and FPGA side. After this there was some consistency in the incorrect values, the first and third rows consistently remained red. Because these rows were the odd rows we determined that the least significant bit was not displaying correctly. To check the overall FPGA logic to ensure that it was properly evaluating this value, we hard coded the value of 1 to the least significant bit. The results of this test was that both of the odd rows started changing to the green color when anticipated. This confirmed that our FPGA logic was correct. To further debug this issue, we tried switching the pins on both the arduino and the FPGA. We then tried probing the line with the oscilloscope and received the correct high voltage signal. This confirmed that FPGA was receiving the signal. Then we tried outputting this value to an LED on the FPGA. The LED however would not light up to the corresponding signal. Another hypothesis that we had about the potential issue is that the sampling rate on the FPGA was too high. We tried switching the 25 clock however this did not fix the issue. Additionally, we changed the delay between the sending of each packet from the arduino to the FPGA in case the FPGA needed more time to read the data. However, this also did not fix our issue.</p>

<p class = "text-left"><a href="https://www.youtube.com/watch?v=vCll1Vz8dtY" target="_blank">Updated - 11/2/2017</a></p>

<p class = "text-left">The updated link above shows the correct simulated movement for the robot based on the information sent from the pair of Arduinos to the FPGA. The main issue that we had was that we were pulling the incorrect voltage drop from our voltage dividers. This meant that the GPIO pins on the FPGA weren’t recieving high enough voltages (about 1.3 volts). This is a problem because the GPIO pins require voltages around 3.3 volts.</p>

<p class = "text-left">Here is the FPGA initialization code:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style="text-align:left"><ul>
 initial begin
    rdy = 0;
   	x1  = 0;
   	x2  = 0;
   	y1  = 0;
   	y2  = 0;
   	y3  = 0;
 end  </ul>
</code></pre></div></div>
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal 5 -->
    <div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
      <h2 id="milestone-1">Milestone 1</h2>

<h3 class = "text-left" id="objective">Objective</h3>

<p class = "text-left">The objective of the milestone was to have the robot follow a line of black tape and traverse a grid in the shape of a figure 8.</p>

<h4 class = "text-left" id="materials">Materials</h4>
<ul class = "text-left">
  <li>5 <a href="https://cdn.sparkfun.com/datasheets/Sensors/Proximity/QRE1113.pdf" target="_blank">QRE-1113 sensors</a></li>
  <li>2 Servos</li>
  <li>A lot of jumper wires</li>
</ul>

<h4 class = "text-left" id="line-following">Line Following</h4>

<p class = "text-left">We connected 5 sensors to the robot: 3 in the front, 2 in the back. We tested each of them to determine a threshold value of 840, for which they would detect white or black. Detecting “white” meant that the analogRead values of the sensors would never exceed 840; detecting “black” meant that the sensors would always read above 840.</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/mile1/robot.JPG" alt="image"></p>

<p class = "text-left">The three front sensors were meant to detect whether the robot was on a line. In our code, when the front middle sensor and one of the front side sensors is sensing the black line, the robot is considered on the line. When one of the side sensors and the front middle sensor are off the line, the robot is considered off the line and the robot will readjust accordingly. The two back side sensors are used to detect cross sections. When the front sensors are on a black line and the back side sensors both detect a black line, the robot is considered on a cross section. Our code is shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style ="text-align:left"><ul>void move(){
  
  if (analogRead(M) &gt;= threshold ){
    leftservo.write(103);     
    rightservo.write(85); 
} 
   //if leftfront and middle sensor is white and rightfront is black, move right, left wheel faster
  else if((analogRead(LF)&lt;=threshold)){
    leftservo.write(98);     
    rightservo.write(94);
  }

   //if rightfront and middle sensor is white and leftfront is black, move left, right wheel faster
  else if(analogRead(RF)&lt;=threshold){
    leftservo.write(94);     
    rightservo.write(89);
  }
}</ul>
</code></pre></div></div>

<p class = "text-left">Our first (presentable) test run worked like <a href="https://youtu.be/_Q0ooO84H1s" target="_blank">this.</a>
We later decided to slow down the servos so that our robot could line follow more smoothly. <a href="https://youtu.be/zvR32bmpkww" target="_blank">Here</a> it is.</p>

<h4 class = "text-left" id="figure-eight">Figure Eight</h4>

<p class = "text-left">We included our line-following code with the figure 8 code to make things easier, and as a result, our figure eight implementation is relatively straight forward: if the back two sensors detected a line, then it meant that the robot was at a cross section, and would subsequently turn right and follow the line (4 times) before turning left and following the line (also 4 times). When turning, we commanded one wheel to stop while allowing the other wheel to keep moving, allowing the robot to turn in the direction of the wheel that had stopped. Below is our code for detecting cross sections:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style="text-align:left"><ul>void move_one(){ //move forward until it's at a cross section
  while((analogRead(LB) &gt;= threshold_l &amp;&amp;analogRead(RB) &gt;=threshold_r)!=true){
    move();}
  leftservo.write(94);     
  rightservo.write(94);   
}</ul>
</code></pre></div></div>

<p class = "text-left">For the turning functionality, we created helper functions <em>turn_left</em> and <em>turn_right</em>. An example is below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style="text-align:left"><ul>void turn_right(){
  leftservo.write(98);      
  rightservo.write(98);
  delay(500);
  while(analogRead(M)&lt;=threshold){
    leftservo.write(98);     
    rightservo.write(98);
  }
}</ul>
</code></pre></div></div>

<p class = "text-left">And as mentioned previously, our <em>figure_eight</em> function was simply having the robot turn right and keep moving until a cross section before turning right again, and turning left after 4 right turns and repeating the same thing.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style="text-align:left"><ul>void figure_eight(){ 
  move_one();
  turn_right();
  move_one();
  turn_right();
  move_one();
  turn_right();
  move_one();
  turn_right();
  move_one();
  turn_left();
  move_one();
  turn_left();
  move_one();
  turn_left();
  move_one();
  turn_left();
  move_one();
}</ul>
</code></pre></div></div>

<p class = "text-left"><a href="https://youtu.be/_kyliNbJiFA" target="_blank">Here</a> is a video of the robot following a figure eight. We later adjusted the back sensor positions and increased the turning speed. <a href="https://youtu.be/0ZVRnUeEuHg" target="_blank">Here</a> is our slightly speedier robot.</p>
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal 6 -->
    <div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
                  
      <h2 id="milestone-2">Milestone 2</h2>

<h3 class = "text-left" id="objective">Objective</h3>

<p class = "text-left">One of the objectives of the milestone was to be able to detect and classify between different treasures (frequencies will be 7kHz, 12kHz, and 17kHz). In addition we had to implement wall detection to the robot.</p>

<h3 class = "text-left" id="treasure-detection">Treasure Detection</h3>
<h4 class = "text-left" id="materials">Materials</h4>
<ul class = "text-left">
  <li><a href="http://www.sharp-world.com/products/device/lineup/data/pdf/datasheet/gp2y0a41sk_e.pdf" target="_blank">Infrared Proximity Sensor Short Range - Sharp GP2Y0A41SK0F</a></li>
  <li>IR treasure</li>
  <li>Oscilliscope</li>
  <li>A line-following robot</li>
  <li><a href="http://www.ti.com/lit/ds/symlink/lm158-n.pdf" target="_blank">TI LM358 Op-Amp</a></li>
  <li>Phototransistor</li>
  <li>Some wires</li>
</ul>

<h4 class = "text-left" id="methods">Methods</h4>
<p class = "text-left">We used the oscilliscope connected to the outputs of the treasure (which is shown in the image below) in order to set the frequency at 7kHz, 12kHz, and 17kHz. We do this to ensure that the values measured by the phototransistor circuit will be as accurate as possible.</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/mile2/treasure_pot.JPG" alt="treasure" /></p>

<p class = "text-left">This video (as shown in Lab 2) reiterates our IR system’s ability to detect and distinguish tones of 7 kHz, 12 kHz, and 17 kHz: <a href="https://www.youtube.com/watch?v=DN9lzJqB21Q" target="_blank">here</a></p>

<p class = "text-left">In this demonstartion, we show our detection for each frequency with a 3 LED setup. The program on the arduino detects the bins that contain the peak of the FFT. Then we output to a certain pin to light the correct LED. We also have an inverting Op-Amp inorder to get a more accurate bin read on the FFT.</p>

<p class = "text-left">Red LED = 7kHz (bins 46 and 47)</p>

<p class = "text-left">Blue LED = 12 kHz (bin 80)</p>

<p class = "text-left">Green LED = 17kHz (bin 114)</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/mile2/treasure_bin_detection.png" alt="treasure FFT graph" /></p>

<h3 class = "text-left" id="wall-detection">Wall Detection</h3>

<p class = "text-left">We attached a <a href="http://www.sharp-world.com/products/device/lineup/data/pdf/datasheet/gp2y0a41sk_e.pdf" target="_blank">distance sensor</a> to the front of our robot so that it could detect walls and stop accordingly.  We added to our previous move_one function (see <a href="https://kristinanemeth.github.io/group14/milestone1.html">Milestone 1</a>) because we wanted our robot to not only detect a wall but also stop at the cross section in front of the wall. It was determined that the values outputted by the distance sensor to the Arduino would start decreasing as it approached the wall. To set this threshold value, we checked the output value over serial for a variety of distances. By sampling the output of the sensor at every 50 ms, we were able to check if the robot was approaching (and a short distance from) the wall at every cross section. We decided to set the robot to stop at the cross sections so that the robot will stop at a position which is easy to renavigate from.</p>

<p class = "text-left">Below is our code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>void move_one(){   

    //move forward until it's at a cross section
    while((analogRead(LB) &gt;= threshold_l &amp;&amp;analogRead(RB) &gt;=threshold_r)!=true){
        move();//  line following function from milestone 1
        past= analogRead(A5); // read and save output 
        delay(50);
        current=analogRead(A5); // read and save output 50ms later
         }
         
   // once at intersection, check to see if robot is approaching
   if(current+15&lt;past){ 
    // included a "buffer" of 15 so that minor disturbances would not cause robot to stop prematurely/unpredictabily
    leftservo.write(94);      
    rightservo.write(94);
    delay(10000);  
   } 
} </ul>
</code></pre></div></div>

<p class = "text-left">See our robot detect and stop at walls <a href="https://www.youtube.com/watch?v=PIjEVcrbemY" target="_blank">here</a> and <a href="https://www.youtube.com/watch?v=ub0Cnr-BQ_A" target="_blank">here</a>.</p>


                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

	<!-- Modal 7 -->
    <div class="portfolio-modal modal fade" id="portfolioModal7" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
                  <h2 id="milestone-3">Milestone 3</h2>

<h3 class = "text-left" id="objectives">Objectives</h3>

<p class = "text-left">The goal of this milestone is to implement algorithm to facilitate maze exploration on a 5x4 grid of this layout:</p>

<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/mile3/mazegrid.jpg" alt="Figure 1. Maze grid" />
Figure 1. Maze grid. Each intersection represents a grid location. “x” is where the robot starts and north is the top of the grid.</p>

<p class = "text-left">Ultimately, we want working algorithm that facilitates maze exploration and indication that all that can be explored has been explored- in simulation and in real life.</p>

<h3 class = "text-left" id="storing-the-maze">Storing the Maze</h3>

<p class = "text-left">Our first step was to decide on how to “translate” a maze into code. We followed the advice of <a href="https://cei-lab.github.io/ECE3400-2017-teamAlpha/milestone3.html" target="_blank">team alpha</a> and chose to save information about the maze in two 5x4 matrices. One 5x4 matrix contains data on whether or not each location on the maze has or has not been explored (1 being unexplored and 0 being explored). Each index of the matrix corresponds to the respective coordinate on the real maze grid. The other matrix contains information about the walls in the maze. Each corresponding index of the matrix contains a decimal number (0 to 15). Each decimal number can be converted to a 4-bit binary number, where each bit will represent the presence (or absence) of a wall. A 1 indicates the absence of a wall and a 0 represents the presence of a wall. Please see Figure I for how we specified directions (“north,” “south” etc.) The bits are organized as follows:
                                              West East South North
           Ex. 0011 would mean there is a wall to the west and east of the robot.</p>

<h3 class = "text-left" id="simulation">Simulation</h3>

<p class = "text-left">Our group chose to implement the simulation in Java. However, we did not know about the simulation code provided to us until we had already implemented depth first search (DFS). Therefore, our algorithm is not compatible with the graphical representation provided to us. However, we are still able to show that our algorithm works!</p>

<h4 class = "text-left" id="a-proof-our-algorithm-works">A. Proof our algorithm works</h4>

<p class = "text-left"><a href="https://www.youtube.com/watch?v=H1WoLMxlXM0" target="_blank">Here</a> is a video of our code running. Here is what our code printed out:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>x location:3
y location:4
...
x location:2
y location:4
...
x location:1
y location:4
...
x location:0
y location:4
...
x location:0
y location:3
...
x location:0
y location:2
...
x location:0
y location:1
...
x location:0
y location:0
...
x location:1
y location:0
...
x location:2
y location:0
...
x location:3
y location:0
...
x location:3
y location:1
...
x location:3
y location:2
...
x location:3
y location:3
...
x location:1
y location:1
...
x location:1
y location:3
...
x location:2
y location:3
...
x location:3
y location:4
...
all searched[[I@7f31245a, [I@6d6f6e28, [I@135fbaa4, [I@45ee12a7, [I@330bedb4, [I@2503dbd3, [I@4b67cf4d, [I@7ea987ac, [I@12a3a380, [I@29453f44, [I@5cad8086, [I@6e0be858, [I@61bbe9ba, [I@610455d6, [I@511d50c0, [I@60e53b93, [I@5e2de80c]
</ul></code></pre></div></div>
<p class = "text-left">Here is the maze we used (both in matrix form and in real life):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>{ { 9, 1, 3, 5 },                    
{ 8, 6, 13, 12}, 
{ 12, 11, 6, 12 }, 
{ 8, 3, 7, 14 }, 
{ 10, 3, 3, 7 } };</ul>
</code></pre></div></div>
<p class = "text-left"><img class="img-fluid d-block mx-auto" src="img/mile3/Maze.jpg" alt="Maze grid" /></p>

<p class = "text-left">Figure 2. This is how the maze would be set up in real life. Picture is taken from video provided by Team Alpha. 
As you can see, the locations our algorithm outputs match the grids the robot traverses in Team Alpha’s <a href="https://www.youtube.com/watch?v=tvfH1x9lJSg" target="_blank">video</a>.</p>

<h4 class = "text-left" id="b-how-we-implemented-our-algorithm-see-mapnavjava-and-arduinojava">B. How we implemented our algorithm (see MapNav.java and Arduino.java)</h4>

<p class = "text-left">We chose to create a Arduino object which contains the current location of our robot ( the x and y coordinates) and the direction our robot is facing.  The appropriate functions ( ie. setters and getters) were implemented. We are assuming that our robot starts at the right-bottom grid. See Figure 1.  The grid corresponds to the index [4][3] on our matrix.  It should be noted that we refer to the “x-coordinate” as the column index and the “y-coordinate” as the row index.</p>

<p class = "text-left">We implemented DFS with two linked lists and used our “frontier” list as a stack. The pseudocode is as follows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>   LinkedList&lt;Arduino&gt; frontier;            // contains grid location that still need to be searched 
   LinkedList&lt;Arduino nodesSearched;         // contains grid locations that have been searched.
   
   while  (frontier is not empty){
      //Pop from top of frontier
      if(there is no wall &amp;&amp; adjacent grid is not in frontier &amp;&amp; adjacent grid is not in nodesSearched){
      //Append adjacent grid locations to top of frontier
    }
    }
        
   //Print out that all possible nodes have been searched
   </ul>
</code></pre></div></div>

<h3 class = "text-left" id="real-life">Real Life</h3>

<p class = "text-left">Our group was tasked with choosing an algorithm to dictate the maze exploration of the robot. We believe that Depth First Search (DFS), would be the best algorithm to use in this case (as we have shown in through our simulation). However, due to time constraints, we were not able to get a DFS algorithm working on our robot. Therefore we tried implementing the wall sensing code with a multiplexer for our multiple analog signals in our robot.</p>

<h4 class = "text-left" id="a--wall-sensing">A . Wall Sensing</h4>
<p class = "text-left">In order to implement depth first search on our robot, we had to implement wall sensing at each of the grid’s intersections to provide wall information to the algorithm. 
Our code for wall sensing tried to accomplish acquiring correcting readings from the three proximity sensors on the front of our robot (one sensor facing left, one sensor facing right, one sensor facing forward) and appropriate testing of these readings. We choose to implement side facing sensors so that the robot could determine all wall locations without turning to use the front wall sensor. This choice helps us maximize for speed.  We approached this in the following four steps (see function wall_locate() in the linked code):</p>
<h4 class = "text-left" id="1">1</h4>
<p class = "text-left">Averaging of values collected from the proximity sensors: At each intersection, we analyzed the incoming data from left, forward, and right proximity sensors. These data values were averaged over 7 iterations so that outlier proximity sensor values did not affect the movement of the robot.</p>
<h4 class = "text-left" id="2">2</h4>
<p class = "text-left">Determining the existence of a wall based on the differences between current and past values: At each intersection, the current wall sensor values are compared to the previous wall sensor values. If the difference between the wall sensor values is higher than 10 then this will be registered as a change in whether a wall was detected or not. As an example if the “current_average” on one sensor at the current intersection has a value 10 lower or higher than the past_average from the past intersection, the sensor will register a change of whether there is a wall in front of it. This change affected the variable wallFront for the front sensor, wallLeft for the left sensor, and wallRight for the right sensor. We negated these boolean variables every time this change was recorded.</p>
<h4 class = "text-left" id="3">3</h4>
<p class = "text-left">Storing the wall information at a specific location: We stored wallFront, wallLeft, and wallRight into a byte variable called currentWallValue for more efficiency in our algorithm and in order to communicate wall information to the DFS() in bit form. Each wall corresponded to a value of 1, 2, or 4 in binary form. For example, if there were walls to the left, right, and forward of the robot this byte variable would be B111.</p>
<h4 class = "text-left" id="4">4</h4>
<p class = "text-left">Testing: We implemented a testing algorithm (not the DFS()) to see if the robot was moving properly according to the current wall information. For example, if there were walls to the front, left, and right of the robot, the robot would have to turn around in order to evade the dead end. The robot’s full turn around was accomplished by calling the function turn_right() twice. 
<a href="https://github.com/kristinanemeth/group14/blob/master/milestone3.ino">Link to Wall Sensing Code</a>.</p>

<h4 class = "text-left" id="b-overall-flow">B. Overall Flow</h4>
<p class = "text-left">The overall setup of the code functioned according the following flowchart:
<img class="img-fluid d-block mx-auto" src="img/mile3/codeblockdiagram.png" alt="Code Flow Chart" />
Move One is the function which prompted the robot to move one intersection forward. At the intersection, the robot would read the wall values as described in the previous section. Upon reading the wall values and determining the walls in the current location as previously described in step 3, the robot would turn in accordance to the wall locations as described previously in step 4. If the robot determined it should loop forward without turning, the code would loop back to move one. If the robot determined that it had searched all the possible locations, the robot would turn on an led. This last section has not been implemented in our code yet, but we plan to implement this section to display that the robot has explored the entire maze. The code for this section can be found at the same link as the wall sensing code.</p>

<h4 class = "text-left" id="c-multiplexer">C. Multiplexer</h4>

<p class = "text-left">We ran out of analog ports for the the sensors, so we decided to implement a mux (model 4051BC) to alternate reading between them – we connected the left wall sensors and the left/right front line sensors of the robot to the mux, and coded the robot to read the sensors as needed. A diagram of our wiring is below:</p>

<p class = "text-left">The total numbers of channels being transmitted to the mux is 4: the left and right IR sensors, and the front left/right line sensors. Pins 10 and 9 were the address bits for the mux, and determined which sensors to set to high and which to low; pin 3 connected the mux to Arduino analog A3, 5-7 to ground, and pin 16 to the Arduino 5V source. Our preliminary code for the mux (2-input only) is shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>int totalChannels = 2;
  int addressA = 2;
  int A = 0;      //Address pin A

  void setup() {
    Serial.begin(9600);
    // Prepare address pins for output
    pinMode(addressA, OUTPUT);
    // Prepare read pin 
    pinMode(A3, INPUT);
  }

  void loop() {
    //Select each pin and read value
    for(int i=0; i&lt;2; i++){
      A = bitRead(i,0); //Take first bit from binary value of i channel.

      //Write address to mux
      digitalWrite(addressA, A);
      //Read and print value

      Serial.print("Channel ");
      Serial.print(i);
      Serial.print(" value: ");
      Serial.println(analogRead(A3));
    
    }
    delay(2000);
  }</ul>
</code></pre></div></div>

<p class = "text-left">We did run into some issues once we added the multiplexer. Once we implemented the mux above on our robot, we started having problems for line detection and wall sensing. When we tested the robot in the maze, the line following became choppier than we have seen and the robot would only turn right. It seemed to detect walls and intersections periodically, so we believe that the problem stems from the numerous iterations that the robot is going through. We believe that this is an issue with the software side and think that it would be best to restart the implementation that we had set up. This way we will have less chance of failure, as we would be looking for any and all bugs periodically rather than merging existing code together.</p>

<h4 class = "text-left" id="implementing-dfs-in-arduino">Implementing DFS in Arduino</h4>

<p class = "text-left">In place of the LinkedList from Java, we will use a library <a href="https://github.com/SloCompTech/QList/blob/master/README.md" target="_blank">QList </a> from Arduino. Additionally, now that our robot is physically moving to different grids, at each “pop” of the stack, we will check to see if the “pop” is adjacent to the current location of the robot. If not, we will iterate through the nodesSearch until we find an adjacent grid that will take us to the new “popped” location.</p>

<p class = "text-left">Additionally, instead of reading in from a hard coded matrix containing information about the walls, we will be using wall information from the distance sensor readings.</p>

<p class = "text-left">In the future, we plan to implement a faster way for the robot to navigate back to a previous location when it reaches a “dead end.” This may include implementing Dijkstra’s algorithm.</p>

<h4 class = "text-left" id="attempts">Attempts</h4>

<p class = "text-left"><a href="https://www.youtube.com/watch?v=TyjdIg3QVlc" target="_blank">Here</a>. is a video of one of our attempts of getting the robot running. The robot can be seen sensing a wall, stopping because of the wall and turning around.</p>
                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
	
	<!-- Modal 8 -->
    <div class="portfolio-modal modal fade" id="portfolioModal8" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="close-modal" data-dismiss="modal">
            <div class="lr">
              <div class="rl"></div>
            </div>
          </div>
          <div class="container">
            <div class="row">
              <div class="col-lg-8 mx-auto">
                <div class="modal-body">
                  <!-- Project Details Go Here -->
                        <h2 id="milestone-3">Milestone 4</h2>

<h3 class = "text-left" id="updates">Updates</h3>

<h4 class = "text-left" id="robot-update">Robot Update:</h4>
<p class = "text-left">To improve the consistency of our robot, we worked to fix a majority of our wiring to make it significantly neater. We switched the breadboard to a (through hole) board with soldered on resistors for the pins which connected directly to the arduino and headers for the power and ground. We additionally switched the male to female wiring on all the line sensors from individual wires to a grouped male to female wire in a set of three for the power, ground and sensor output lines. These changes made our robot easier to debug and created less disconnection of wires.</p>

<h4 class = "text-left" id="milestone-3-update">Milestone 3 update:</h4>
<p class = "text-left">We switched to storing our locations for DFS in an int array instead of using the QList because we were worried about memory. Now, we only have to save an integer array and an additional integer which serves as our “pointer” in the array. Every time we “pop”  a location, we decrease the pointer value and every time we add to the “stack,” we write into the array and then increment the pointer.</p>

<p class = "text-left"><a href="https://www.youtube.com/watch?v=uH1z1_MfQ2Y" target="_blank">Here</a> is a video of our maze mapping.</p>

<h3 class = "text-left" id="objectives">Objectives</h3>
<p class = "text-left">For this milestone, we needed a system that could display the walls and treasure in a maze as the robot found them. We also needed our system to display a “done” signal on the screen, and play a “done” signal on the speaker when the maze was successfully mapped.</p>

<h3 class = "text-left" id="treasure-detection-and-display">Treasure Detection and Display</h3>
<p class = "text-left">To do the treasure detection, we simply have to integrate the code and hardware from lab 2 into the DFS code. We copied the circuit from Lab 2 three times over (1 for each treasure detector implemented - left, front, and right) and connected three LEDs to the remaining digital outputs of the Arduino. We will have to reorganize our current mux to wire the additional treasure detectors, since we ran out of analog pins. Below are our new select signals and their corresponding outputs:</p>
<table style="width:100%">
  <tr>
    <th>Select Bits</th>
    <th>Input Number</th> 
    <th>Sensor Output</th>
  </tr>
  <tr>
    <td>000</td>
    <td>Y0</td>
    <td>Left Front Line Sensor</td>
  </tr>
  <tr>
    <td>001</td>
    <td>Y1</td>
    <td>Right Front Line Sensor</td>
  </tr>
  <tr>
    <td>010</td>
    <td>Y2</td>
    <td>Left Wall Sensor</td>
  </tr>
  <tr>
    <td>011</td>
    <td>Y3</td>
    <td>Right Wall Sensor</td>
  </tr>
  <tr>
    <td>100</td>
    <td>Y4</td>
    <td>Front Treasure Detector</td>
  </tr>
  <tr>
    <td>101</td>
    <td>Y5</td>
    <td>Right Treasure Detector</td>
  </tr>
  <tr>
    <td>110</td>
    <td>Y6</td>
    <td>Left Treasure Detector</td>
  </tr>
  <tr>
    <td>111</td>
    <td>Y7</td>
    <td>Microphone</td>
  </tr>
</table><br>
<p class = "text-left">We plan on connecting the microphone to the empty Y7 slot.</p>

<p class = "text-left">To incorporate the treasure detection in our main code, we will only need minor changes from the previous labs, since our Lab 2 code is already working. This will likely require two functions in our main code: treasure_detect and treasure_display. Treasure_detect will iterate through the analog pins 4-7 to detect if there was a treasure available and output 00 (no treasure), 01 (7 kHz), 10 (12 kHz), and 11 (17 kHz) depending on treasure availability and frequency. Treasure_display will light the appropriate LEDs as dictated by treasure_detect output .The fft bin number will also have to be changed, since it takes up a large amount of Arduino memory and we’re utilizing three treasure detectors instead of just one.</p>

<h3 class = "text-left" id="wall-display-on-the-fpga">Wall Display on the FPGA</h3>

<p class = "text-left">Our DFS code already handles the wall detection and converts the wall sensor data into something which can be sent to the FPGA in 4 bits where each bit represents the presence and absence of a wall. Additionally, at each “move_to” function, we are able to output the location of the robot in five bits.</p>

<p class = "text-left">We improved our Lab 4 FPGA Display by adding walls to each grid space in the 5 x 4 grid array. We took in wall data from the receiving side of the radio transmission on the Arduino through four additional GPIO pins on the FPGA.</p>

<p class = "text-left">We added memory array registers for the walls which were wall1, wall2, wall3, and wall4 for the top wall, bottom wall, left wall, and right wall respectively.
This was the beginning and end of our memory array initialization:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>wall1[0][0] = 8'b000_000_00;
wall1[0][1] = 8'b000_000_00;
wall1[0][2] = 8'b000_000_00;
…
wall4[3][2] = 8'b000_000_00;
wall4[3][3] = 8'b000_000_00;
wall4[3][4] = 8'b000_000_00;</ul>
</code></pre></div></div>
<p class = "text-left">Based on the binary values received from the four additional GPIO pins, we set the walls at each grid space utilizing the memory array above. We change the color from our screen background (black: 8’b000_000_00) to white (8’b111_111_11). 
Wall Determination at a Grid Point:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>if (val == 1'b1) begin
    if (wallFront) begin 
          	wall1[grid_coord_x][grid_coord_y] = 8'b111_111_11; 
    end
   	 
    if (wallBottom) begin
        	wall2[grid_coord_x][grid_coord_y] = 8'b111_111_11;
    end

    if (wallLeft) begin	 
          	wall3[grid_coord_x][grid_coord_y] = 8'b111_111_11;	 
    end
   	 
    if (wallRight) begin
        	wall4[grid_coord_x][grid_coord_y] = 8'b111_111_11;
    end
end</ul>
</code></pre></div></div>
<p class = "text-left">Once we set the walls at a certain grid space, we displayed the updated representation of the maze by iterating over memory array within the double for loop we implemented in Lab 3:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code style = "text-align:left"><ul>//Upper Walls
if(((j * PIXEL_WIDTH + 10'd0 &lt; PIXEL_COORD_X) &amp;&amp; (PIXEL_COORD_X &lt; (j + 10'd1) * PIXEL_WIDTH - 10'd5)) &amp;&amp; ((i * PIXEL_HEIGHT &lt; PIXEL_COORD_Y) &amp;&amp; (PIXEL_COORD_Y &lt; (i + 10'd1) * PIXEL_HEIGHT - 10'd5))) begin
PIXEL_COLOR = wall1[j][i];
end</ul>
</code></pre></div></div>
<p class = "text-left">The video <a href="https://www.youtube.com/watch?v=h1z6HrVaSnU" target="_blank">here</a> displays how our wall data is displayed on the screen.</p>

<h3 class = "text-left" id="done-signal">Done Signal</h3>

<p class = "text-left">Our above implementation does not currently include a “done” message; however, we plan to include this into our final design by adding another connection between the receiving arduino and fpga that will send a high value when the dfs() reaches the “all nodes searched” state which is included in our original dfs() function. The DFS already displays “all nodes searched” on the serial monitor screen when the algorithm is complete.</p>

<p class = "text-left">While we did not have the chance to implement the done signal using FPGA, we have determined our plan for implementation. The done signal will be displayed once the DFS algorithm has finished. To indicate that this being done, the robot’s current location square will turn purple which will signify that it has finished its search. This signal will be sent from the arduino on the robot that is running the DFS.</p>

<h3 class = "text-left" id="done-sound">Done Sound</h3>
<p class = "text-left">While we did not have the chance to implement the done sound, we have determined our plan for implementation. We will implement the same setup as used in lab 3, this includes an 8-bit DAC with the digital side wired to an FPGA and the analog side connected to the auxiliary jack. We will use the tri tone signal created in the lab to signify done. Please refer to <a href="https://kristinanemeth.github.io/group14/lab3.html">lab 3 on our website</a> for more information on the setup and code. The FPGA in use will be the same FPGA that is receiving the transmitted information from the robot and is used to display the map. This sound will be triggered by the same signal which will display the done signal.</p>



                  <button class="btn btn-primary" data-dismiss="modal" type="button">
                    <i class="fa fa-times"></i>
                    Close Project</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
	
	
	
    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Contact form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/agency.min.js"></script>

  </body>

</html>

